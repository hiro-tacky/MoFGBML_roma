 package cilabo.gbml.operator.crossover;

import java.util.ArrayList;
import java.util.List;

import org.uma.jmetal.component.replacement.Replacement;
import org.uma.jmetal.component.selection.MatingPoolSelection;
import org.uma.jmetal.component.selection.impl.NaryTournamentMatingPoolSelection;
import org.uma.jmetal.operator.crossover.CrossoverOperator;
import org.uma.jmetal.solution.util.attribute.util.attributecomparator.AttributeComparator;
import org.uma.jmetal.solution.util.attribute.util.attributecomparator.impl.IntegerValueAttributeComparator;
import org.uma.jmetal.util.JMetalException;
import org.uma.jmetal.util.checking.Check;
import org.uma.jmetal.util.pseudorandom.BoundedRandomGenerator;
import org.uma.jmetal.util.pseudorandom.JMetalRandom;
import org.uma.jmetal.util.pseudorandom.RandomGenerator;

import cilabo.data.DataSet;
import cilabo.data.pattern.Pattern;
import cilabo.gbml.component.replacement.RuleAdditionStyleReplacement;
import cilabo.gbml.operator.mutation.MichiganMutation;
import cilabo.gbml.solution.michiganSolution.MichiganSolution;
import cilabo.gbml.solution.pittsburghSolution.PittsburghSolution;
import cilabo.gbml.solution.util.SortMichiganPopulation;
import cilabo.gbml.solution.util.attribute.ErroredPatternsAttribute;
import cilabo.gbml.solution.util.attribute.NumberOfClassifiedPatterns;
import cilabo.main.Consts;
import cilabo.utility.GeneralFunctions;
import cilabo.utility.Random;

public class MichiganCrossover
		<pittsburghSolution extends PittsburghSolution<michiganSolution>,
		michiganSolution extends MichiganSolution<?>>
		implements CrossoverOperator<pittsburghSolution> {

	private double crossoverProbability;
	private RandomGenerator<Double> crossoverRandomGenerator;
	private BoundedRandomGenerator<Integer> selectRandomGenerator;
	DataSet<?> train;

	/** Constructor */
	public MichiganCrossover(double crossoverProbability, DataSet<?> train) {
		this( crossoverProbability, train,
			() -> JMetalRandom.getInstance().nextDouble(),
			(a, b) -> JMetalRandom.getInstance().nextInt(a, b));
		this.train = train;
	}

	/** Constructor */
	public MichiganCrossover(
			double crossoverProbability, DataSet<?> train, RandomGenerator<Double> randomGenerator) {
		this( crossoverProbability, train,
			randomGenerator,
			BoundedRandomGenerator.fromDoubleToInteger(randomGenerator));
	}

	/** Constructor */
	public MichiganCrossover(
			double crossoverProbability, DataSet<?> train,
			RandomGenerator<Double> crossoverRandomGenerator,
			BoundedRandomGenerator<Integer> selectRandomGenerator) {
		if(crossoverProbability < 0) {
			throw new JMetalException("Crossover probability is negative: " + crossoverProbability);
		}
		this.train = train;
		this.crossoverProbability = crossoverProbability;
		this.crossoverRandomGenerator = crossoverRandomGenerator;
		this.selectRandomGenerator = selectRandomGenerator;
	}

	/* Getter */
	@Override
	public double getCrossoverProbability() {
		return this.crossoverProbability;
	}

	@Override
	public int getNumberOfRequiredParents() {
		return 1;
	}

	@Override
	public int getNumberOfGeneratedChildren() {
		return 1;
	}

	@Override
	public List<pittsburghSolution> execute(List<pittsburghSolution> solutions) {
		Check.isNotNull(solutions);
		Check.that(solutions.size() == 1, "There must be single parent instead of " + solutions.size());
		return doCrossover(crossoverProbability, solutions.get(0));
	}

	/**
	 * 後件部の学習はここではしない
	 * @param probability
	 * @param _parent
	 * @return
	 */
	public List<pittsburghSolution> doCrossover(double probability, pittsburghSolution parent) {
		// Cast IntegerSolution to PittsburghSolution

		List<michiganSolution> generatedMichiganSolution = new ArrayList<>();

		/* Step 1. Calculate number of all of generating rules. */
		int numberOfRulesOnParent = parent.getNumberOfVariables();
		int numberOfGeneratingRules = (int) (numberOfRulesOnParent*Consts.RULE_CHANGE_RT + 1);

		/* Step 2. Calculate numbers of rules generated by GA and Heuristic rule generation method. */
		int numberOfHeuristic;
		if(numberOfGeneratingRules % 2 == 0) {
			numberOfHeuristic = numberOfGeneratingRules/2;
		}else {
			int plus = selectRandomGenerator.getRandomValue(0, 1);
			numberOfHeuristic = (numberOfGeneratingRules-1)/2 + plus;
		}

		/* Step 3. Heuristic Rule Generation */
		if( 0<numberOfHeuristic ) {
			@SuppressWarnings("unchecked")
			List<Pattern<?>> erroredPatterns = (ArrayList<Pattern<?>>) parent.getAttribute(new ErroredPatternsAttribute<>().getAttributeId());
			//誤識別パターンが足りないor無い場合は，ランダムなパターンをリストに追加
			int NumberOfLack = numberOfHeuristic - erroredPatterns.size();
			for(int i = 0; i < NumberOfLack; i++) {
				Pattern<?> pattern = train.getPattern(Random.getInstance().getGEN()
						.nextInt(train.getDataSetSize()));
				erroredPatterns.add(pattern);
			}
			//Sampling patterns without replacement from erroredPatterns.
			Integer[] erroredPatternsIndex = GeneralFunctions.samplingWithout(erroredPatterns.size(),
					numberOfHeuristic,
					Random.getInstance().getGEN());
			for(Integer pattern_i : erroredPatternsIndex) {
				Pattern<?> pattern = erroredPatterns.get(pattern_i);
				michiganSolution michiganSolution = parent.getMichiganSolutionBuilder().createMichiganSolution(pattern);
				generatedMichiganSolution.add(michiganSolution);
			}
		}

		/* Step 4. Rule Generation by Genetic Algorithm - Michigan-style GA */
		int NumberOfGA = numberOfGeneratingRules - numberOfHeuristic;
		if( 0<NumberOfGA ) {

			/* Crossover: Uniform crossover */
			UniformCrossover<michiganSolution> crossover = new UniformCrossover<michiganSolution>(Consts.MICHIGAN_CROSS_RT);
			/* Mutation: Michigan-style specific mutation operation */
			double mutationProbability = 1.0 / (double)train.getNumberOfDimension();
			MichiganMutation<michiganSolution>  mutation = new MichiganMutation<michiganSolution>(mutationProbability, train);
			/* Mating Selection: Binray tournament */
			int tournamentSize = 2;
			if(parent.getNumberOfVariables() == 1) {
				/* If number of rules for parent is 1, then tournamentSize will be set 1.
				 * This is regards as that crossover operation is not performed. */
				tournamentSize = 1;
			}
			int matingPoolSize = NumberOfGA *
					crossover.getNumberOfRequiredParents() / crossover.getNumberOfGeneratedChildren();
			MatingPoolSelection<michiganSolution> selection = new NaryTournamentMatingPoolSelection<michiganSolution>(
					tournamentSize,
					matingPoolSize,
					new IntegerValueAttributeComparator<michiganSolution>(new NumberOfClassifiedPatterns<michiganSolution>().getAttributeId(),
							AttributeComparator.Ordering.DESCENDING)
					);
			/* == GA START == */
			/* Mating Selection */
			List<michiganSolution> matingPopulation = selection.select((List<michiganSolution>) parent.getVariables());
			/* Offspring Generation */
			List<michiganSolution> generatedSolutionByGA = new ArrayList<>();
			int numberOfParents = crossover.getNumberOfRequiredParents();
			for(int i = 0; i < matingPoolSize; i+= numberOfParents) {
				List<michiganSolution> parents = new ArrayList<>();
				for(int j = 0; j < numberOfParents; j++) {
					parents.add(matingPopulation.get(i + j));
				}
				List<michiganSolution> offspring = null;
				/* Crossover: Uniform crossover */
				offspring = crossover.execute(parents);
				/* Mutation */
				for(michiganSolution s : offspring) {
					mutation.execute(s);
					s.learning();
				}
				if(!GeneralFunctions.checkRule((List<MichiganSolution<?>>) offspring)) {
					offspring = new ArrayList<michiganSolution>(parents);
				}

				for(michiganSolution michiganSolution_tmp : offspring) {
					generatedSolutionByGA.add(michiganSolution_tmp);
					if(generatedSolutionByGA.size() == NumberOfGA) {
						break;
					}
				}
			}
			/* == GA END == */

			// Merge rules (generated by Heuristic) and rules (generated by GA)
			generatedMichiganSolution.addAll(generatedSolutionByGA);
		}

		/* Replacement: Single objective maximization repelacement */
		Replacement<michiganSolution> replacement = new RuleAdditionStyleReplacement<michiganSolution>();
		List<michiganSolution> parentMichiganSolution = new ArrayList<>();
		List<michiganSolution> childMichiganSolution = new ArrayList<>();
		//Deep copy
		for(int i = 0; i < parent.getNumberOfVariables(); i++) {
			parentMichiganSolution.add((michiganSolution) parent.getVariable(i).copy());
		}
		childMichiganSolution = replacement.replace(parentMichiganSolution, generatedMichiganSolution);

		/* Pittsburgh solution */
		pittsburghSolution child = (pittsburghSolution) parent.copy();
		child.clearVariables();
		child.clearAttributes();

		// Radix sort Michigan solution list
		SortMichiganPopulation.radixSort((List<MichiganSolution<?>>) childMichiganSolution);
		/* Set variables */
		for(michiganSolution childMichiganSolution_tmp: childMichiganSolution) {
			child.addVariable(childMichiganSolution_tmp);
		}

		List<pittsburghSolution> offspring = new ArrayList<>();
		offspring.add(child);
		return offspring;
	}


//	@Deprecated
//	/**
//	 * 交叉操作内で後件部の学習をしてしまうため，
//	 * 突然変異操作を行うと再学習が必要となり，学習回数（計算コスト）が無駄になる．
//	 * 使用予定が無ければ，廃止推奨．
//	 * @param probability
//	 * @param parent ピッツバーグ型の個体1体
//	 * @return
//	 */
//	public List<IntegerSolution> doCrossover2(double probability, IntegerSolution parent){
//		// Cast IntegerSolution to PittsburghSolution
//		PittsburghSolution_deprecated pittsburghParent = (PittsburghSolution_deprecated)parent;
//		List<Pair<Integer, Integer>> boundsMichigan = ((MichiganSolution_Basic)pittsburghParent.getMichiganPopulation().get(0).copy()).getBounds();
//		int numberOfObjectivesMichigan = ((MichiganSolution_Basic)pittsburghParent.getMichiganPopulation().get(0)).getNumberOfObjectives();
//		int numberOfConstraintsMichigan = ((MichiganSolution_Basic)pittsburghParent.getMichiganPopulation().get(0)).getNumberOfConstraints();
//
//		List<IntegerSolution> michiganPopulation = new ArrayList<>();
//
//		/* Step 1. Calculate number of all of generating rules. */
//		int numberOfRulesOnParent = ((RuleBasedClassifier)pittsburghParent.getClassifier()).getRuleNum();
//		int numberOfGeneratingRules = (int)((numberOfRulesOnParent - 0.00001)*Consts.RULE_CHANGE_RT) + 1;
//
//		/* Step 2. Calculate numbers of rules generated by GA and Heuristic rule generation method. */
//		int numberOfHeuristic;
//		if(numberOfGeneratingRules % 2 == 0) {
//			numberOfHeuristic = numberOfGeneratingRules/2;
//		}
//		else {
//			int plus = selectRandomGenerator.getRandomValue(0, 1);
//			numberOfHeuristic = (numberOfGeneratingRules-1)/2 + plus;
//		}
//
//		/* Step 3. Heuristic Rule Generation */
//		@SuppressWarnings("unchecked")
//		List<Integer> erroredPatterns = (List<Integer>)parent.getAttribute((new ErroredPatternsAttribute<IntegerSolution>()).getAttributeId());
//		DataSet train = consequentFactory.getTrain();
//		//誤識別パターンが足りないor無い場合は，ランダムなパターンをリストに追加
//		int NumberOfLack = numberOfHeuristic - erroredPatterns.size();
//		for(int i = 0; i < NumberOfLack; i++) {
//			int id = train.getPattern(Random.getInstance().getGEN()
//						.nextInt(train.getDataSize()))
//					.getID();
//			erroredPatterns.add(id);
//		}
//		//Sampling patterns without replacement from erroredPatterns.
//		Integer[] erroredPatternsIdx = GeneralFunctions.samplingWithout(erroredPatterns.size(),
//																		numberOfHeuristic,
//																		Random.getInstance().getGEN());
//		for(int i = 0; i < erroredPatternsIdx.length; i++) {
//			Pattern_i pattern = train.getPatternWithID(erroredPatterns.get(erroredPatternsIdx[i]));
//			Antecedent generatedAntecedent = heuristicRuleGeneration.heuristicRuleGeneration(pattern);
//			Consequent consequent = (Consequent) consequentFactory.learning(generatedAntecedent);
//			MichiganSolution_Basic michiganSolution = new MichiganSolution_Basic(boundsMichigan,
//																	 numberOfObjectivesMichigan,
//																	 numberOfConstraintsMichigan,
//																	 generatedAntecedent, consequent);
//			michiganPopulation.add(michiganSolution);
//		}
//
//		/* Step 4. Rule Generation by Genetic Algorithm - Michigan-style GA */
//		int NumberOfGA = numberOfGeneratingRules - numberOfHeuristic;
//		/* Crossover: Uniform crossover */
//		CrossoverOperator<IntegerSolution> crossover = new UniformCrossover(Consts.MICHIGAN_CROSS_RT);
//		/* Mutation: Michigan-style specific mutation operation */
//		double mutationProbability = 1.0 / (double)train.getNdim();
//		MutationOperator<IntegerSolution> mutation = new MichiganMutation(mutationProbability,
//																		  heuristicRuleGeneration.getKnowledge(),
//																		  train);
//		/* Variation: */
//		Variation<IntegerSolution> variation = new MichiganSolutionVariation<>(
//													NumberOfGA,	// offspringSize
//													crossover, mutation,
//													heuristicRuleGeneration.getKnowledge(),
//													consequentFactory);
//		/* Mating Selection: Binray tournament */
//		int tournamentSize = 2;
//		MatingPoolSelection<IntegerSolution> selection = new NaryTournamentMatingPoolSelection<>(
//														tournamentSize,
//														variation.getMatingPoolSize(),
//														new ObjectiveComparator<>(0, ObjectiveComparator.Ordering.DESCENDING));
//		/* == GA START == */
//		// Mating Selection
//		List<IntegerSolution> matingPopulation = selection.select(pittsburghParent.getMichiganPopulation());
//		// Offspring Generation
//		List<IntegerSolution> generatedSolutionByGA = variation.variate(pittsburghParent.getMichiganPopulation(),
//																		matingPopulation);
//
//		/* Replacement: Single objective maximization repelacement */
//		Replacement<IntegerSolution> replacement = new RuleAdditionStyleReplacement();
//		// Merge rules (generated by Heuristic) and rules (generated by GA)
//		michiganPopulation.addAll(generatedSolutionByGA);
//
//		List<IntegerSolution> currentList = new ArrayList<>();
//		//Deep copy
//		for(int i = 0; i < pittsburghParent.getMichiganPopulation().size(); i++) {
//			currentList.add((IntegerSolution)pittsburghParent.getMichiganPopulation().get(i).copy());
//		}
//		currentList = replacement.replace(currentList, michiganPopulation);
//
//
//		// Pittsburgh solution
//		IntegerSolution child = new PittsburghSolution_deprecated(
//									pittsburghParent.getBounds(),
//									pittsburghParent.getNumberOfObjectives(),
//									currentList,
//									((RuleBasedClassifier)pittsburghParent.getClassifier()).getClassification() );
//
//		List<IntegerSolution> offspring = new ArrayList<>();
//		offspring.add(child);
//
//		return offspring;
//	}


}

